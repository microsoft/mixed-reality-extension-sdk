App to App Interactions
===========

This document describes an extension to the SDK to allow MRE apps to receive content (e.g., photos) from the MRE clients. Content may be generated by the client itself, or, in future iterations not yet described here, may arrive from other apps with coordination from a particular client.

In Altspace, for example, this feature would allow the user to share photos to an MRE, which could be seen by others.

## API Design
This design introduces the concept of a `SharingMessage`, a base class of content-specific messages, such as `PhotoSharingMessage`. We provide an outline for the implementation of `PhotoSharingMessage` only, but expect to add more sharing capabilities over time.

`SharingMessage` is itself relatively straightforward, but contains enough information to allow the recipient (callback listener) to cast it to the appropriate type (e.g., `PhotoSharingMessage`). We envision multiple message types and don't want to add a registration api for each.

```ts
export class SharingMessage {
    messageType: Readonly<string>;
    sessionId: Readonly<string>;
    userId: Readonly<Guid>;
}

export class PhotoSharingMessage extends SharingMessage {
    mimeType: Readonly<string>; // Supported values: "image/jpeg" and "image/png"
    data: Readonly<Buffer>; // Raw bytes of an image file in the mimeType format above. Not populated for the IsMessageDesiredCallback
    dataSize: Readonly<number>; // size in bytes of the data array. This IS popuplated in the IsMessageDesiredCallback 
}
```

`SharingCallbacks` are a relatively straightforward callback registration mechanism, with an optional mechanism to allow the callback registrant to stop processing of messages and construction of payloads in cases where a particular message would not be acted on.

```ts

// Fires before the MessageReceivedCallback. When the implementation
// returns false, may short-circuit additional data transfer or processing
// related to the message. The contents of the message may not be complete,
// for example, a PhotoSharingMessage will not have any photo data.
// Note that this callback is optional but may be useful if the
// application is unable or uninterested in acting on all messages.
export interface IsMessageDesiredCallback { 
    (sharingMessage: SharingMessage) : boolean
}

export interface MessageReceivedCallback {
    (sharingMessage: SharingMessage) : void
}

export class SharingCallbacks {
    // Note that this callback is optional (See IsMessageDesiredCallback).
    // Leave null to process all messages 
    public isMessageDesired : IsMessageDesiredCallback;
    public messageReceived : MessageReceivedCallback;
}
```

Callbacks are registered (and deregistered) via new functions on the context described below.

For the sake of simplicity, only one callback may be registered on a particular session context at a time for a given callback type. We can relax this restriction in the future, as it's future proof, if application needs require. In the meantime, this restriction simplifies the work required to determine if messages are desired and may allow for a more simple implementation within the the sharing implementation on both the app side and the client runtime See [Implementation Suggestions](#Implementation-Suggestions)

```ts
// Modifications to
// https://github.com/microsoft/mixed-reality-extension-sdk/blob/master/packages/sdk/src/core/context.ts

/**
 * Registers a set of callbacks invoked at various points in the processing
 * of a sharing message. Only one callback may be registered at a time
 * for a given callback type.
 *
 * The messageReceived callback must be defined, but the isMessageDesired
 * callback is optional.
 *
 * Returns true if the callback was successfully registered.
 * @event
 */
public onSharingMessage(messageType: string, callbacks: SharingCallbacks): boolean {
    // [... Register listener ...]
    return true; // If successful
}

/**
 * Removes the onSharingMessage callback, if it is registered.
 *
 * Returns true if the callback was successfully unregistered.
 * @event
 */
public offSharingMessage(messageType: string, callbacks: SharingCallbacks): boolean {
    // [... Deregister listener ...]
    return true; // If successful
}
```

## Implementation Suggestions

1. Modify `context` to expose callback registration mechanism
2. Adjust `contextInternal` and perhaps `multiPeerAdapter` to message the desire for each MessageType callback to each client (and corresponding remove messages). For callbacks registered for all sessions or all users, this my be sent after connect
3. Implement the "Photo" message type. Send and receive encoded photos via the existing websocket used by multiPeerAdapter. Future message types (e.g., streaming video) may need to establish related side-channels.

### Sample data flow for photo sharing
1. On connect (or on subsequent sharing message registration), MRE app sends a `SharingRegistration` json payload consisting of
    * `messageType` - `string` (as Described in [API Design](#API-Design))
2. MRE Client sends a `SharingMessage` json payload, consiting of the following fields (as Described in [API Design](#API-Design))
    * `messageId` - `string` (randomly generated guid)
    * `messageType` - `string` 
    * `photoType` - `string`
    * `dataSize` - `number`
    * `transmissionMethod` - `string`, presently set to the value "restbinary", but may be extended, for example, to support alternative trasnport for existing message types such as json messages on the primary channel (for smaller payloads)
3. MRE app invokes `SharingCallbacks.isMessageDesired` callback if present to determine whether the message is desired. If a `SharingCallback` is registered for the given `messageType` but no `isMessageDesired` is present, proceed as if the message IS desired. If no `SharingCallback` is registered for the given `messageType`, proceed as if the message is NOT desired.
4. MRE app sends a `SharingMessageResponse` json payload, consiting of the following fields:
    * `result` - `boolean` true if the message is desired, false otherwise.
5. If the message was desired, the MRE host should transmit the bytes of the image via a restful call, to an endpoint such as `/api/share/image/:sessionId/:messageId` as described in [Binary Side Channel](#Binary-Side-Channel) 
6. MRE app invokes `SharingCallbacks.messageReceived` with a payload similar to that of step 2, with the additional binary data of the image on the payload.
7. MRE app sends a `SharingMessageResponse` similar to step 4, indicating whether the message was successfully received by an appropriate handler.

Note that future sharing message types for content smaller than images may forgo steps 4 and 5 and elect to send their entire payload with the initial json sent in step 2.

### Binary Side Channel
Certain message types, such as images, are not suitable for transmission on the primary websocket. We considered adding a new websocket side channel, but due to http server port restrictions, decided on a new rest endpoint (`/api/share/image/:sessionId/:messageId`) which should accept the binary portion of the message and route it to the appropriate session within the `multipeeradapter`.

The restify web server configuration for this binding should reject the message if it was not expected as per the negotiation which previously occured on the websocket.

Return a success or error code from the REST endpoint based on whether or not the post payload was received in full. This does not necessarily indicate that the message was accepted by the APP, but may help a host retry transmission in the event of a network error.

The MRE app should invoke the `SharingCallbacks.messageReceived` and send the `SharingMessageResponse` as described above, based on whether or not the message was successfully routed and accepted by the app (see final steps of the sample data flow for photo sharing above)
