App to App Interactions
===========

This document describes an extension to the SDK to allow MRE apps to receive content (e.g., photos) from the MRE clients. Content may be generated by the client itself, or, in future iterations not yet described here, may arrive from other apps with coordination from a particular client.

In Altspace, for example, this feature would allow the user to share photos to an MRE, which could be seen by others.

## API Design
This design introduces the concept of a `SharingMessage`, a base class of content-specific messages, such as `PhotoSharingMessage`. We provide an outline for the implementation of `PhotoSharingMessage` only, but expect to add more sharing capabilities over time.

`SharingMessage` is itself relatively straightforward, but contains enough information to allow the recipient (callback listener) to cast it to the appropriate type (e.g., `PhotoSharingMessage`). We envision multiple message types and don't want to add a registration api for each.

```ts
class SharingMessage {
    messageType: Readonly<string>;
    sessionId: Readonly<string>;
    userId: Readonly<Guid>;
}

class PhotoSharingMessage extends SharingMessage {
    mimeType: Readonly<string>; // Supported values: "image/jpeg" and "image/png"
    data: Readonly<Buffer>; // Raw bytes of an image file in the mimeType format above. Not populated for the IsMessageDesiredCallback
    dataSize: Readonly<Number>; // size in bytes of the data array. This IS popuplated in the IsMessageDesiredCallback 
}
```

`SharingCallbacks` are a relatively straightforward callback registration mechanism, with an optional mechanism to allow the callback registrant to stop processing of messages and construction of payloads in cases where a particular message would not be acted on.

```ts

// Fires before the MessageReceivedCallback. When the implementation
// returns false, may short-circuit additional data transfer or processing
// related to the message. The contents of the message may not be complete,
// for example, a PhotoSharingMessage will not have any photo data.
// Note that this callback is optional but may be useful if the
// application is unable or uninterested in acting on all messages.
interface IsMessageDesiredCallback { 
    (sharingMessage: SharingMessage) : bool
}

interface MessageReceivedCallback {
    (sharingMessage: SharingMessage) : void
}

class SharingCallbacks {
    // Note that this callback is optional (See IsMessageDesiredCallback).
    // Leave null to process all messages 
    public isMessageDesired : IsMessageDesiredCallback;
    public messageReceived : MessageReceivedCallback;
}
```

Callbacks are registered (and deregistered) via new functions on the context described below.

For the sake of simplicity, only one callback may be registered on a particular session context at a time for a given callback type. We can relax this restriction in the future, as it's future proof, if application needs require. In the meantime, this restriction simplifies the work required to determine if messages are desired and may allow for a more simple implementation within the the sharing implementation on both the app side and the client runtime See [Implementation Suggestions](#Implementation-Suggestions)

```ts
// Modifications to
// https://github.com/microsoft/mixed-reality-extension-sdk/blob/master/packages/sdk/src/core/context.ts

/**
 * Registers a set of callbacks invoked at various points in the processing
 * of a sharing message. Only one callback may be registered at a time
 * for a given callback type.
 *
 * The messageReceived callback must be defined, but the isMessageDesired
 * callback is optional.
 *
 * Returns true if the callback was successfully registered.
 * @event
 */
public onSharingMessage(messageType: string, callbacks: SharingCallbacks): bool {
    // [... Register listener ...]
    return true; // If successful
}

/**
 * Removes the onSharingMessage callback, if it is registered.
 *
 * Returns true if the callback was successfully unregistered.
 * @event
 */
public offSharingMessage(messageType: string, callbacks: SharingCallbacks): bool {
    // [... Deregister listener ...]
    return true; // If successful
}
```

## Implementation Suggestions

1. Modify `context` to expose callback registration mechanism
2. Adjust `contextInternal` and perhaps `multiPeerAdapter` to message the desire for each MessageType callback to each client (and corresponding remove messages). For callbacks registered for all sessions or all users, this my be sent after connect
3. Implement the "Photo" message type. Send and receive encoded photos via the existing websocket used by multiPeerAdapter. Future message types (e.g., streaming video) may need to establish related side-channels.

### Sample data flow for photo sharing
1. On connect (or on subsequent sharing message registration), MRE app sends a `SharingRegistration` json payload consisting of
    * `messageType` - `string` (as Described in [API Design](#API-Design))
2. MRE Client sends a `SharingMessage` json payload, consiting of the following fields (as Described in [API Design](#API-Design))
    * `messageId` - `string` (randomly generated guid)
    * `messageType` - `string` 
    * `photoType` - `string`
    * `dataSize` - `number`
    * `transmissionMethod` - `string`, presently set to the value "websocketbinary", but may be extended, for example, to support alternative trasnport for existing message types such as json messages on the primary channel (for smaller payloads)
3. MRE app invokes `SharingCallbacks.isMessageDesired` callback if present to determine whether the message is desired. If a `SharingCallback` is registered for the given `messageType` but no `isMessageDesired` is present, proceed as if the message IS desired. If no `SharingCallback` is registered for the given `messageType`, proceed as if the message is NOT desired.
4. MRE app sends a `SharingMessageResponse` json payload, consiting of the following fields:
    * `result` - `boolean` true if the message is desired, false otherwise.
5. If the message was desired, the MRE host should establish a [Binary Side Channel](#Binary-Side-Channel) and transmit the bytes of the image immediately following the `SharingMessageResponse` in binary format as per https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
6. MRE app invokes `SharingCallbacks.messageReceived` with a payload similar to that of step 2, with the additional binary data of the image on the payload.
7. MRE app sends a `SharingMessageResponse` similar to step 4, indicating whether the message was successfully received by an appropriate handler

Note that future sharing message types for content smaller than images may forgo steps 4 and 5 and elect to send their entire payload with the initial json sent in step 2.


### Binary Side Channel
Certain message types, such as images, are not suitable for transmission on the primary websocket. In these cases a websocket bound to an additional port (TODO: Pick port number) will accept connections to handle expected payloads.

There is little back and forth on the binary side channel. After connecting:

1. the client should send (as a string), the same json payload of the `SharingMessage` (in string format) followed by the corresponding binary payload (`send(ArrayBuffer)` or `send(Blob)`) totaling `dataSize` bytes. 
2. The app should then close the connection:
    * if the `messageId` is unexpected (i.e., not previously accepted on the main websocket via the `isMessageDesired` mechansim described above) or undesired
    * after receiving `dataSize` bytes.
3. the MRE app should invoke the `SharingCallbacks.messageReceived` and send the `SharingMessageResponse` as described above, based on whether or not the message was successfully received.
